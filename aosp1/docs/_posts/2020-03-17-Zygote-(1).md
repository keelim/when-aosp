---
layout: post
title: "Zygote (1)"
date: 2020-03-17 00:00:01
author: Keelim
categories: AOSP
comments: true
toc: true
toc_sticky: true
---
## Zygote: ì•ˆë“œë¡œì´ë“œì—ì„œ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ ì‹œìŠ¤í…œ -> ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ì™€ ë‹¤ë¥´ë‹¤

![Zygote](https://raw.githubusercontent.com/keelim/AOSP/master/docs/assets/zy1.png)

![Zygote fork()](https://raw.githubusercontent.com/keelim/AOSP/master/docs/assets/zy2.png)

## Zygoteê°€ ì‹¤í–‰ë˜ëŠ” ê³¼ì • ì½”ë“œë¡œ ì‚´í´ë³´ê¸°

### app_processë¡œë¶€í„° ZygoteInit class ì‹¤í–‰

- app_process : ë‹¬ë¹… ê°€ìƒ ë¨¸ì‹  ìƒì„±, ê°€ìƒ ë¨¸ì‹  ì—ì„œ ZygoteInit í´ë˜ìŠ¤ë¥¼ ë¡œë”© ë° ì‹¤í–‰

#### (1) init í”„ë¡œì„¸ìŠ¤ê°€ app_process ì‹¤í–‰  

```java
// android froyo
// system/core/rootdir/init.rc ì¤‘ service zygote

service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    socket zygote stream 666
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
```

```cpp
app_process -Xzygote /system/bin --zygote --start-system-server
```

- app_process ì‹¤í–‰ ê·œì¹™  

```cpp
app_process [java-options] cmd-dir start-class-name [options]
```

- java-options : ê°€ìƒë¨¸ì‹ ìœ¼ë¡œ ì „ë‹¬ë˜ëŠ” ì˜µì…˜  
- cmd-dir : í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë  ë””ë ‰í† ë¦¬  
- start-class-name : ê°€ìƒ ë¨¸ì‹ ì—ì„œ ìƒì„±í•  í´ë˜ìŠ¤ ì´ë¦„, app_processëŠ” ì „ë‹¬ë°›ì€ í´ë˜ìŠ¤ë¥¼ ê°€ìƒ ë¨¸ì‹  ë¡œë”© í›„ í•´ë‹¹ í´ë˜ìŠ¤ì˜ main() í˜¸ì¶œ  
- options : ì‹¤í–‰ë  í´ë˜ìŠ¤ ì „ë‹¬ ì˜µì…˜  

---

#### AppRuntime ê°ì²´ ìƒì„± ë° ì‹¤í–‰

```cpp
// android froyo
// app_process/app_main.cpp ì¤‘ main í•¨ìˆ˜

int main(int argc, const char* const argv[])
{
    // These are global variables in ProcessState.cpp
    mArgC = argc;
    mArgV = argv;

    mArgLen = 0;
    for (int i=0; i<argc; i++) {
        mArgLen += strlen(argv[i]) + 1;
    }
    mArgLen--;
    AppRuntime runtime; // (2)
    const char *arg;
    const char *argv0;
    argv0 = argv[0];
    // Process command line arguments
    // ignore argv[0]
    argc--;
    argv++;
    // Everything up to '--' or first non '-' arg goes to the vm

    int i = runtime.addVmArguments(argc, argv); // (3)
    // Next arg is parent directory
    if (i < argc) {
        runtime.mParentDir = argv[i++]; // (4)
    }
    // Next arg is startup classname or "--zygote"
    if (i < argc) {
        arg = argv[i++];
        if (0 == strcmp("--zygote", arg)) { // (5)
            bool startSystemServer = (i < argc) ?
                    strcmp(argv[i], "--start-system-server") == 0 : false;
            setArgv0(argv0, "zygote");
            set_process_name("zygote");
            runtime.start("com.android.internal.os.ZygoteInit",
                startSystemServer); // (6)
        } else {
            set_process_name(argv0);
            runtime.mClassName = arg;
            // Remainder of args get passed to startup class main()
            runtime.mArgC = argc-i;
            runtime.mArgV = argv+i;
            LOGV("App process is starting with pid=%d, class=%s.\n",
                 getpid(), runtime.getClassName());
            runtime.start();
        }
    } else {
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        return 10;
    }
}
```

#### (2) AppRuntime ê°ì²´ ìƒì„±

AppRuntime ê°ì²´ëŠ” AndroidRuntime í´ë˜ìŠ¤ë¥¼ ìƒì†
AndroidRuntime í´ë˜ìŠ¤ëŠ” ë‹¬ë¹… ê°€ìƒ ë¨¸ì‹ ì„ ì´ˆê¸°í™”, ì‹¤í–‰í•œë‹¤.  

#### (3) main() í•¨ìˆ˜ì— ì „ë‹¬ëœ ì¸ì ê°’ì„ ë¶„ì„í•´ì„œ AppRuntime ê°ì²´ì— ì „ë‹¬

-Xzygote ê°’ì€ AppRuntimeì˜ mOption ë³€ìˆ˜ì— ì €ì¥  

#### (4) ì‹¤í–‰ ë””ë ‰í† ë¦¬ ê²½ë¡œ /system/binì€ AppRuntimeì˜ mParentDir ë³€ìˆ˜ ì €ì¥  

#### (5) ê°€ìƒ ë¨¸ì‹ ì—ì„œ ìƒì„±í•  í´ë˜ìŠ¤ ì´ë¦„ í™•ì¸  

í´ë˜ìŠ¤ ì´ë¦„ì´ --zygoteì¸ê°€ ì•„ë‹ˆê°€ì— ë”°ë¼ ì²˜ë¦¬ ê³¼ì •ì´ ë‹¬ë¼ì§€ì§€ë§Œ ê²°êµ­ ê°€ìƒ ë¨¸ì‹  ìƒì—ì„œ ì£¼ì–´ì§„ í´ë˜ìŠ¤ë¥¼ ë¡œë”©í•œë‹¤.

#### (6) AppRuntimeì˜ start() ë©¤ë²„ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ

ê°€ìƒ ë¨¸ì‹ ì´ ìƒì„± ë° ì´ˆê¸°í™”
ê°€ìƒ ë¨¸ì‹ ì—ì„œ ZygoteInit í´ë˜ìŠ¤ë¥¼ ë¡œë”©í•˜ê³  main() ë©”ì†Œë“œë¡œ ì‹¤í–‰ íë¦„ì´ ë°”ë€œ
runtime()ì˜ ì²« ë²ˆì§¸ ì¸ìë¡œ í´ë˜ìŠ¤ì˜ íŒ¨í‚¤ì§€ ì´ë¦„ê³¼ í´ë˜ìŠ¤ ì´ë¦„ì„ ëª…ì‹œ  
íŒ¨í‚¤ì§€ë¥¼ ê²½ë¡œë¡œ í•´ì„í•´ ZygoteInit í´ë˜ìŠ¤ë¥¼ ì°¾ì•„ ë¡œë”©í•œë‹¤.  
runtime.start() ë‘ ë²ˆì§¸ ì¸ìëŠ” --start-system-serverê°€ ì „ë‹¬ëìœ¼ë¯€ë¡œ true

### ë‹¬ë¹… ê°€ìƒ ë¨¸ì‹  ìƒì„±

```cpp
// android froyo
// framework/base/core/jni/AndroidRuntime.cpp ì¤‘ startVM() í•¨ìˆ˜, start() í•¨ìˆ˜

/*
 * Start the Dalvik Virtual Machine.
 *
 * Various arguments, most determined by system properties, are passed in.
 * The "mOptions" vector is updated.
 *
 * Returns 0 on success.
 */
int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)
{

    // ìƒëµ

    enum {
      kEMDefault,
      kEMIntPortable,
      kEMIntFast,
#if defined(WITH_JIT)
      kEMJitCompiler,
#endif
    } executionMode = kEMDefault;

    property_get("dalvik.vm.checkjni", propBuf, ""); // (8)
    if (strcmp(propBuf, "true") == 0) {
        checkJni = true;
    } else if (strcmp(propBuf, "false") != 0) {
        /* property is neither true nor false; fall back on kernel parameter */
        property_get("ro.kernel.android.checkjni", propBuf, "");
        if (propBuf[0] == '1') {
            checkJni = true;
        }
    }
    property_get("dalvik.vm.execution-mode", propBuf, "");

    // ìƒëµ

    if (JNI_CreateJavaVM(pJavaVM, pEnv, &initArgs) < 0) { // (9)
        LOGE("JNI_CreateJavaVM failed\n");
        goto bail;
    }
    result = 0;
bail:
    free(stackTraceFile);
    return result;
}



/*
 * Start the Android runtime.  This involves starting the virtual machine
 * and calling the "static void main(String[] args)" method in the class
 * named by "className".
 */
void AndroidRuntime::start(const char* className, const bool startSystemServer)
{
    LOGD("\n>>>>>>>>>>>>>> AndroidRuntime START <<<<<<<<<<<<<<\n");
    char* slashClassName = NULL;
    char* cp;
    JNIEnv* env;
    blockSigpipe();
    /*
     * 'startSystemServer == true' means runtime is obslete and not run from
     * init.rc anymore, so we print out the boot start event here.
     */
    if (startSystemServer) {
        /* track our progress through the boot sequence */
        const int LOG_BOOT_PROGRESS_START = 3000;
        LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,
                       ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));
    }
    const char* rootDir = getenv("ANDROID_ROOT");
    if (rootDir == NULL) {
        rootDir = "/system";
        if (!hasDir("/system")) {
            LOG_FATAL("No root directory specified, and /android does not exist.");
            goto bail;
        }
        setenv("ANDROID_ROOT", rootDir, 1);
    }
    //const char* kernelHack = getenv("LD_ASSUME_KERNEL");
    //LOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);
    /* start the virtual machine */
    if (startVm(&mJavaVM, &env) != 0) // (7)
        goto bail;
    /*
     * Register android functions.
     */
    if (startReg(env) < 0) { // (10)
        LOGE("Unable to register all android natives\n");
        goto bail;
    }
    /*
     * We want to call main() with a String array with arguments in it.
     * At present we only have one argument, the class name.  Create an
     * array to hold it.
     */
    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;
    jstring startSystemServerStr;
    stringClass = env->FindClass("java/lang/String");
    assert(stringClass != NULL);
    strArray = env->NewObjectArray(2, stringClass, NULL);
    assert(strArray != NULL);
    classNameStr = env->NewStringUTF(className);
    assert(classNameStr != NULL);
    env->SetObjectArrayElement(strArray, 0, classNameStr);
    startSystemServerStr = env->NewStringUTF(startSystemServer ?
                                                 "true" : "false");
    env->SetObjectArrayElement(strArray, 1, startSystemServerStr);
    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.
     */
    jclass startClass;
    jmethodID startMeth;
    slashClassName = strdup(className);
    for (cp = slashClassName; *cp != '\0'; cp++) // (11)
        if (*cp == '.')
            *cp = '/';
    startClass = env->FindClass(slashClassName); // (12)
    if (startClass == NULL) {
        LOGE("JavaVM unable to locate class '%s'\n", slashClassName);
        /* keep going */
    } else {
        startMeth = env->GetStaticMethodID(startClass, "main", // (13)
            "([Ljava/lang/String;)V");
        if (startMeth == NULL) {
            LOGE("JavaVM unable to find main() in '%s'\n", className);
            /* keep going */
        } else {
            env->CallStaticVoidMethod(startClass, startMeth, strArray); // (14)
#if 0
            if (env->ExceptionCheck())
                threadExitUncaughtException(env);
#endif
        }
    }
    LOGD("Shutting down VM\n");
    if (mJavaVM->DetachCurrentThread() != JNI_OK)
        LOGW("Warning: unable to detach main thread\n");
    if (mJavaVM->DestroyJavaVM() != 0)
        LOGW("Warning: VM did not shut down cleanly\n");
bail:
    free(slashClassName);
}

static const RegJNIRec gRegJNI[] = {
    REG_JNI(register_android_debug_JNITest),
    REG_JNI(register_com_android_internal_os_RuntimeInit),
    REG_JNI(register_android_os_SystemClock),
    REG_JNI(register_android_util_EventLog),
    REG_JNI(register_android_util_Log),

    // ìƒëµ

};



/*
 * Register android native functions with the VM.
 */
/*static*/ int AndroidRuntime::startReg(JNIEnv* env)
{
    /*
     * This hook causes all future threads created in this process to be
     * attached to the JavaVM.  (This needs to go away in favor of JNI
     * Attach calls.)
     */
    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);
    LOGD("--- registering native functions ---\n");
    /*
     * Every "register" function calls one or more things that return
     * a local reference (e.g. FindClass).  Because we haven't really
     * started the VM yet, they're all getting stored in the base frame
     * and never released.  Use Push/Pop to manage the storage.
     */
    env->PushLocalFrame(200);
    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {
        env->PopLocalFrame(NULL);
        return -1;
    }
    env->PopLocalFrame(NULL);
    //createJavaThread("fubar", quickTest, (void*) "hello");
    return 0;
}
```

#### (7) startVM()

(8)ê³¼ (9)ë¥¼ ì‹¤í–‰.  

#### (8) property_get() í•¨ìˆ˜ í˜¸ì¶œ

ê°€ìƒ ë¨¸ì‹ ì˜ ì‹¤í–‰ ì˜µì…˜ ì„¤ì •.  

#### (9) JNI_CreateJavaVM() í•¨ìˆ˜ë¥¼ í˜¸ì¶œ

ë‹¬ë¹… ê°€ìƒ ë¨¸ì‹ ì„ ìƒì„±í•˜ê³  ì‹¤í–‰
`JavaVM **pVm` : ìƒì„±ëœ JavaVM í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ í¬ì¸í„°  
`JNIEnv **p_env` : ê°€ìƒ ë¨¸ì‹ ì— ì ‘ê·¼í•˜ê¸° ìœ„í•œ JNIEnv í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ í¬ì¸í„°  
`void *vm_args` : ì§€ê¸ˆê¹Œì§€ ì„¤ì •í•œ ê°€ìƒ ë¨¸ì‹ ì˜ ì˜µì…˜  

---

### ìƒì„±ëœ ê°€ìƒë¨¸ì‹ ì—ì„œ ì‚¬ìš©í•  JNI í•¨ìˆ˜ ë“±ë¡

#### (10) startReg() í•¨ìˆ˜

gRegJNI[] ë°°ì—´ì— ì €ì¥ë˜ì–´ ìˆëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
ê°€ìƒ ë¨¸ì‹  ìƒì—ì„œ ì‚¬ìš©í•  JNI í•¨ìˆ˜ë¥¼ ë“±ë¡í•˜ê³  ë‚˜ë©´, ê°€ìƒ ë¨¸ì‹  ìƒì—ì„œ ë™ì‘í•˜ëŠ” ìë°” í´ë˜ìŠ¤ì—ì„œ ì´ ë„¤ì´í‹°ë¸Œ í•¨ìˆ˜ë“¤ì„ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤.  

---

![Zygote ì´ ì‹¤í–‰](https://raw.githubusercontent.com/keelim/AOSP/master/docs/assets/zy3.png)

#### ZygoteInit í´ë˜ìŠ¤ì˜ ì‹¤í–‰

ìƒì„±ëœ VMì—ì„œ ë™ì‘í•  í´ë˜ìŠ¤ ë¡œë”© ë¶€ë¶„

app_processëŠ” ì „ë‹¬ëœ ì¸ìì— ë”°ë¼ Zygote ì™¸ì˜ ë‹¤ë¥¸ í´ë˜ìŠ¤ë¥¼ í˜¸ì¶œ
ì—¬ê¸°ì„œëŠ” Zygote í´ë˜ìŠ¤ë¥¼ í˜¸ì¶œ

ì—¬ê¸°ì„œ ì¸ìë¡œ ì „ë‹¬ëœ classNameì€ `com.android.internal.os.ZygoteInit`ì´ë‹¤.

#### (11) í´ë˜ìŠ¤ ì´ë¦„ì˜ `.`ì„ `/`ë¡œ ì¹˜í™˜

ì•„ë˜ì˜ ì½”ë“œ (12)ì—ì„œ ê²½ë¡œì— ë“¤ì–´ ìˆëŠ” í´ë˜ìŠ¤ë¥¼ ì½ì–´ë“¤ê¸°ì´ ë•Œë¬¸ì´ë‹¤.

#### (12) FindClass() í•¨ìˆ˜

ì‹¤í–‰í•  í´ë˜ìŠ¤ë¥¼ ë¡œë”©

#### (13) GetStaticMethodID() í•¨ìˆ˜

í•´ë‹¹ í´ë˜ìŠ¤ì—ì„œ ë§¤ê°œë³€ìˆ˜ê°€ String ë°°ì—´ì´ê³  ë°˜í™˜ê°’ì´ Voidì´ë©°, ì •ì  ë©”ì„œë“œì¸ main() ì°¾ìŒ

#### (14) main method í˜¸ì¶œ

ë©”ì¸ ë©”ì„œë“œë¥¼ í˜¸ì¶œ, ì‹¤í–‰ íë¦„ì€ ê°€ìƒ ë¨¸ì‹  ìœ„ì—ì„œ ë™ì‘í•˜ëŠ” ìë°” ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ ë°”ë€œ
ì—¬ê¸°ì„œëŠ” ZygoteInit í´ë˜ìŠ¤ë¡œ ì‹¤í–‰ íë¦„ì´ ë„˜ì–´ê°.

ì´í›„ ë„¤ì´í‹°ë¸Œ ì˜ì—­ì—ì„œ ì§„í–‰ë˜ì–´ì˜¨ C++ ì½”ë“œì˜ ì‹¤í–‰íë¦„ì€ ê°€ìƒ ë¨¸ì‹ ì´ ì¢…ë£Œë  ë•Œ ê¹Œì§€ ì§„í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤.  

ê°€ìƒ ë¨¸ì‹ ì„ ìƒì„±í•˜ê³  ZygoteInit í´ë˜ìŠ¤ë¥¼ ë¡œë”© ì™„ë£Œ.  

## references

- <https://source.android.com>
- <https://developer.android.com>
- ì¸ì‚¬ì´ë“œ ì•ˆë“œë¡œì´ë“œ
- Android Internals Vol 1
- Embedded Android
- <https://android.googlesource.com/platform/frameworks/base/>

#### ğŸ§¶ ëª¨ë“  ë¬¸ì„œëŠ” ìˆ˜ì •ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
